<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[(function(){}())与(function(){})()与$(function(){})与（fuction(){}）]]></title>
    <url>%2F2019%2F07%2F07%2F(function()%7B%7D())%E4%B8%8E(function()%7B%7D)()%E4%B8%8E%24(function()%7B%7D)%E4%B8%8E%EF%BC%88fuction()%7B%7D%2F</url>
    <content type="text"><![CDATA[前两个都是写法不同的立即执行函数，立即执行函数特性详见笔记 &lt;p style=&quot;background-color:rgb(148 139 80);color:#000&quot;&gt;(ps：立即执行函数与匿名自执行函数是不同的：立即执行函数可以是匿名也可以不匿名他的特征是立即执行完然后销毁自身，匿名自执行函数必须是匿名的并且特征是自己引用自己，自己调用自己来执行，如：&lt;/p&gt; &lt;!-- more --&gt; 1var demo1=function()&#123;demo1();&#125;) 或者 1var demo2=function()&#123;arguments.callee();&#125; //必须用arguments.callee()来执行自己 定义一个函数有两种方式 ：&lt;span style=&quot;color:red;font-weight:bold&quot;&gt;函数声明语句：fucntion functionName(){}&lt;/span&gt;和&lt;span style=&quot;color:orange;font-weight:bold&quot;&gt;函数表达式：var name=function(){}&lt;/span&gt;； &lt;span style=&quot;color:rgb(151 54 50);font-weight:bold&quot;&gt;立即执行函数的原理是必须是函数表达式&lt;/span&gt;才能给方法加上小括号让其自执行，如果是函数声明语句后边加上小括号让他自执行是会报错的，所以立即执行函数写法都是让function不成为首行关键字(当关键字function出现在首行他就是一个函数语句，语句是没有返回结果的)，让他成为一个函数表达式（作为函数表达式就有返回结果了）如（function（）{}（））或者(function（）{ })() ，或者var save=function(){}()；或者 ` [function(){}()] ` ` ~function(){}() ` ` +function(){}() ` ` -function(){}() ` ` !function(){}() ` ` void function(){}() ` &lt;p style=&quot;color:Red&quot;&gt;总之，要让函数立即执行他必须是个函数表达式 （立即执行与自执行）详见参考：https://www.cnblogs.com/TomXu/archive/2011/12/31/2289423.html $(function(){})与$(documnet).ready(function(){})的简写，在dom加载完后执行的回调函数，并且只会执行一次 (functon(){})匿名函数，后边通常用立即执行函数来调用：（function(){}()）或者(function(){})()]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[pc端及移动端样式重置]]></title>
    <url>%2F2019%2F06%2F30%2F%E6%A0%B7%E5%BC%8F%E9%87%8D%E7%BD%AEreset%2F</url>
    <content type="text"><![CDATA[常用pc端重置全局样式reset.css 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879html&#123;font-family:"Microsoft YaHei UI","Microsoft YaHei",sans-serif;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%&#125;html,body,div,object,iframe,applet,object,h1,h2,h3,h4,h5,h6,p,blockquote,pre,address,dl,dt,dd,ol,ul,li,table,caption,tbody,tfoot,thead,tr,th,td,article,aside,canvas,details,embed,figure,figcaption,footer,header,menu,nav,output,ruby,section,summary,time,mark,audio,video,progress&#123;margin:0;padding:0;border:0;vertical-align:baseline&#125;li&#123;list-style:none&#125;article,aside,details,figcaption,figure,footer,header,main,menu,nav,section,summary&#123;display:block&#125;audio,canvas,progress,video&#123;display:inline-block&#125;audio:not([controls])&#123;display:none;height:0&#125;[hidden],template&#123;display:none&#125;a&#123;background-color:transparent;text-decoration:none&#125;a:active,a:hover&#123;outline:0&#125;abbr[title]&#123;border-bottom:1px dotted&#125;b,strong&#123;font-weight:bold&#125;dfn&#123;font-style:italic&#125;h1&#123;font-size:2em;margin:.67em 0&#125;mark&#123;background:#ff0;color:#000&#125;small&#123;font-size:80%&#125;sub,sup&#123;font-size:75%;line-height:0;position:relative;vertical-align:baseline&#125;sup&#123;top:-0.5em&#125;sub&#123;bottom:-0.25em&#125;img&#123;border:0&#125;svg:not(:root)&#123;overflow:hidden&#125;figure&#123;margin:1em 40px&#125;hr&#123;-moz-box-sizing:content-box;box-sizing:content-box;height:0&#125;pre&#123;overflow:auto&#125;code,kbd,pre,samp&#123;font-family:monospace,monospace;font-size:1em&#125;button,input,optgroup,select,textarea&#123;color:inherit;font:inherit;margin:0;outline:none;line-height:normal&#125;button&#123;overflow:visible&#125;button,select&#123;text-transform:none&#125;button,html input[type="button"],input[type="reset"],input[type="submit"]&#123;-webkit-appearance:button;cursor:pointer&#125;button[disabled],html input[disabled]&#123;cursor:default&#125;button::-moz-focus-inner,input::-moz-focus-inner&#123;border:0;padding:0&#125;input&#123;line-height:normal&#125;input[type="checkbox"],input[type="radio"]&#123;box-sizing:border-box;padding:0&#125;input[type="number"]::-webkit-inner-spin-button,input[type="number"]::-webkit-outer-spin-button&#123;height:auto&#125;input[type="search"]&#123;-webkit-appearance:textfield;-moz-box-sizing:content-box;-webkit-box-sizing:content-box;box-sizing:content-box&#125;input[type="search"]::-webkit-search-cancel-button,input[type="search"]::-webkit-search-decoration&#123;-webkit-appearance:none&#125;fieldset&#123;border:1px solid silver;margin:0 2px;padding:.35em .625em .75em&#125;legend&#123;border:0;padding:0&#125;textarea&#123;overflow:auto&#125;optgroup&#123;font-weight:bold&#125;table&#123;border-collapse:collapse;border-spacing:0&#125;td,th&#123;padding:0&#125; 常用移动端重置样式reset.css 1234567891011121314151617181920212223242526272829303132333435363738394041424344@charset "utf-8";/* 禁用iPhone中Safari的字号自动调整 */html &#123; -webkit-text-size-adjust: 100%; -ms-text-size-adjust: 100%;&#125;/* 去除iPhone中默认的input样式 */input[type="submit"], input[type="reset"], input[type="button"], input&#123;-webkit-appearance:none; resize: none;&#125;/* 取消链接高亮 */body,div,ul,li,ol,h1,h2,h3,h4,h5,h6,input,textarea,select,p,dl,dt,dd,a,img,button,form,table,th,tr,td,tbody,article, aside, details,figcaption,figure,footer,header,hgroup, menu,nav,section&#123; -webkit-tap-highlight-color:rgba(0, 0, 0, 0); &#125;/* 设置HTML5元素为块 */article, aside, details,figcaption,figure,footer,header,hgroup, menu,nav,section &#123;display: block;&#125;/* 图片自适应 */img &#123;max-width: 100%;height: auto;width:auto\9; /* ie8 */-ms-interpolation-mode:bicubic;/*为了照顾ie图片缩放失真*/&#125;/* 初始化 */body,div,ul,li,ol,h1,h2,h3,h4,h5,h6,input,textarea,select,p,dl,dt,dd,a,img,button,form,table,th,tr,td,tbody,article, aside, details,figcaption,figure,footer,header,hgroup, menu,nav,section&#123;margin:0; padding:0; border:none;&#125;body&#123;font: normal 14px/1.5 Tahoma,"Lucida Grande",Verdana,"Microsoft Yahei",STXihei,hei;&#125;em,i&#123;font-style:normal;&#125;strong&#123;font-weight: normal;&#125;.clearfix:after&#123;content:""; display:block; visibility:hidden; height:0; clear:both;&#125;.clearfix&#123;zoom:1;&#125;a&#123;text-decoration:none; color:#969696; font-family: '宋体',Microsoft YaHei,Tahoma,Arial,sans-serif;&#125;a:hover&#123;color:#fff; text-decoration:none;&#125;ul,ol&#123;list-style:none;&#125;h1, h2, h3, h4, h5, h6&#123; font-size:100%; font-family: Microsoft YaHei;&#125;img&#123;border: none;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[var const let class]]></title>
    <url>%2F2019%2F06%2F23%2Fvar%20const%20%20let%20class%2F</url>
    <content type="text"><![CDATA[const 和 let,class 都是在定义所在范围内有效，不会被外部环境所影响（暂时性死区），即使是定义全局变量，该属性也不属于GO的属性，而var 则可以变量提升，在function内声明一个全局变量，该变量依旧是GO的属性，从而污染外部环境，var的这一特性的引用如for循环实现计数 var 可以先使用后定义不会报错，而const 和let class 必须先定义后使用 const 声明的简单变量或者常量，是只读的且必须在定义的同时赋值初始化，否则会报错，猜测原理是： js引擎在处理变量的时候，有三大要素：变量名、内存空间和内存地址，当内存空间里的值被改变时，即重新定义赋值变量，新的值会覆盖旧的值（代码上看起来像覆盖），其实是js引擎重新分配另一个空间给新的值，并与内存地址绑定，到了某个时间，js引擎会回收掉旧的空间，而const在定义赋值简单变量的时候，与对应的内存地址与存的值是不可更改的，所以无法重新定义赋值 但是const在声明复杂变量时(比如数组或者对象)，初始化绑定的指针地址是不可更改的，但里边的数据可以更改]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端XSS攻击]]></title>
    <url>%2F2019%2F06%2F16%2F%E5%89%8D%E7%AB%AFXSS%E6%94%BB%E5%87%BB%2F</url>
    <content type="text"><![CDATA[定义：XSS攻击（跨域脚本攻击），Crose Site Scripting指攻击者在网页中嵌入脚本代码，如JS代码，当用户访问网页时，脚本在用户的浏览器上执行，从而窃取用户的cookie信息、导航到恶意网站、携带木马等 以达到攻击者的操作目的。大部分的xss漏洞都是由于没有处理好用户的输入，导致攻击脚本在浏览器中执行，这就是跨站脚本漏洞的根源。 类型：XSS攻击的类型一般分为以下三种： 1.存储型XXS2.反射型XXS攻击3.dom型XXS 存储型XSS： 1.攻击者在用户输入时插入恶意代码，将恶意代码提交到目标数据库里 2.用户访问目标网站时提取数据库信息，存在数据库里的恶意代码被拼接返回给浏览器 3.浏览器响应执行，并且执行恶意代码 4.攻击者窃取用户信息，并发送到攻击者的网站，达到攻击目的 解决方案： 存储型XSS攻击主要是通过在用户的输入里嵌入恶意代码，从而造成XXS攻击。 进行HTMLencode处理 / 对用户输入做限制，杜绝攻击者插入攻击代码的可能如：正则限制，长度限制，关键字限制: JavaScript、 alert 、onclick等 A：前端提交前转码：encodeHtml(value) B：后端java转码：Encoder.encodeHtml(value)；如果是Param类，直接使用.getHtmlString(key)。 反射型XSS攻击 1.攻击者制造特殊URL，用户打开带有恶意代码的 URL。 2.用户访问目标网站，服务端截取url并拼接返回给浏览器 3.浏览器响应执行携带攻击代码的URL 4.攻击者窃取用户信息，并发送到攻击者的网站，或者冒充用户的行为，调用目标网 站接口执行攻击者指定的操作。 解决方案： 反射型XSS攻击与存储型XXS攻击的主要区别在于：存储型攻击是攻击代码存储在数据库，反射型则是存储在URL中；相同点是：同样是在服务端造成的XXS攻击。 数据提交时一定要对传参数的数进行URLencode处理 / 对用户输入做限制，杜绝攻击者插入攻击代码的可能如：正则限制，长度限制，关键字限制：JavaScript、 alert 、onclick等 前端提交参数前：encodeUrl(url); B：后端拿到数据进行编码：Encoder.encodeURL(url); dom型XSS攻击 1.攻击者构造出特殊的 URL，其中包含恶意代码，用户打开带有恶意代码的 URL。 2.用户浏览器接收到响应后解析执行，前端 JavaScript 取出 URL 中的恶意代码并执行。 3.恶意代码窃取用户数据并发送到攻击者的网站，或者冒充用户的行为，调用目标网 站接口执行攻击者指定的操作。 解决方案： dom型XSS攻击与前两者攻击的不同之处在于dom型攻击是发生在前端取出和执行恶意代码由浏览器端完成，属于前端 JavaScript 自身的安全漏洞，而其他两种 XSS 都属于服务端的安全漏洞。 a.在append前，进行keywordCond编码 / 对用户输入做限制，杜绝攻击者插入攻击代码的可能如：正则限制，长度限制，关键字限制：onclick等 A：在append前，将keywordCond进行编码 keywordCond = encodeUrlComponent(keywordCond)； scripts.append(keywordCond) B：后台调用方法： String keywordCond = Encoder.encodeHtmlJs(keywordCond); b.将重要的cookie标记为http only, 这样的话当浏览器向Web服务器发起请求的时就会带上cookie字段，但是在脚本中却不能访问这个cookie，这样就避免了XSS攻击利用JavaScript的document.cookie获取cookie。 eg: A：Tomcat服务器，在Tomcat下的conf的web.xml设置如下信息。 &lt;session-config&gt; &lt;cookie-config&gt; &lt;http-only&gt;true&lt;/http-only&gt; &lt;/cookie-config&gt; &lt;session-config&gt; B：resin服务器，在resin.conf下设置session信息。 &lt;session-config&gt; &lt;enable-cookies&gt;true&lt;/enable-cookies&gt; &lt;cookie-config&gt; &lt;http-only&gt;true&lt;/http-only&gt; &lt;/cookie-config&gt; &lt;/session-config&gt; 总结： 前端和后端尽可能对提交数据做好过滤。要注意在正确的地方使用正确的编码方式，有时为了防御XSS，在一个地方我们需要联合HTMLEncode、JavaScriptEncode、URLEncode进行编码，甚至是叠加，并不是固定一种方式编码，具体情况具体分析。 针对XSS攻击类型，我们日常开发需要做好以下部分：1. 在HTML标签、属性中输出时，用HTMLEncode。2. 在script标签中输出时，用JavaScriptEncode。3. 在地址中输出一般如果变量是整个URL，则用URLEncode。4. 在提交数据前，做一些正则校验，或者在输入框中做一些限制]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>javascript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue2]]></title>
    <url>%2F2019%2F05%2F20%2FVue2%2F</url>
    <content type="text"><![CDATA[对于MVVM的理解MVVM 是 Model-View-ViewModel 的缩写 Model: 代表数据模型，也可以在Model中定义数据修改和操作的业务逻辑。我们可以把Model称为数据层，因为它仅仅关注数据本身，不关心任何行为 view: 用户操作界面。当ViewModel对Model进行更新的时候，会通过数据绑定更新到View ViewModel： 业务逻辑层，View需要什么数据，ViewModel要提供这个数据；View有某些操作，ViewModel就要响应这些操作，所以可以说它是Model for View. 总结： MVVM模式简化了界面与业务的依赖，解决了数据频繁更新。MVVM 在使用当中，利用双向绑定技术，使得 Model 变化时，ViewModel 会自动更新，而 ViewModel 变化时，View 也会自动变化。 开发中常用的指令 v-model:一般用在表达输入，很轻松的实现表单控件和数据的双向绑定 v-html: 更新元素的 innerHTML v-show 与 v-if: 条件渲染, 注意二者区别 使用了v-if的时候，如果值为false，那么页面将不会有这个html标签生成。 v-show则是不管值为true还是false，html元素都会存在，只是CSS中的display显示或隐藏 * v-on : click: 可以简写为 @click ,@绑定一个事件。如果事件触发了，就可以指定事件的处理函数 v-for: 基于源数据多次渲染元素或模板块 v-bind: 当表达式的值改变时，将其产生的连带影响，响应式地作用于 DOM 语法：v-bind:title=”msg”简写：:title=”msg” 对vue生命周期的理解vue生命周期总共分为8个阶段: 创建前/后，载入前/后，更新前/后， 销毁前/后。 beforeCreate （创建前） vue实例的挂载元素$el和数据对象 data都是undefined, 还未初始化 created (创建后) 完成了 data数据初始化, el还未初始化 beforeMount (载入前) vue实例的$el和data都初始化了, 相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。注意此时还没有挂载html到页面上。 mounted (载入后) 在el 被新创建的 vm.$el替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html页面中。此过程中进行ajax交互 beforeUpdate (更新前) 在数据更新之前调用，发生在虚拟DOM重新渲染和打补丁之前。可以在该钩子中进一步地更改状态，不会触发附加的重渲染过程。 updated （更新后） 在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。调用时，组件DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。 beforeDestroy (销毁前） 在实例销毁之前调用。实例仍然完全可用。 destroyed (销毁后） 在实例销毁之后调用。调用后，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务器端渲染期间不被调用。 Vue的双向数据绑定原理vue.js 是采用数据劫持结合发布者-订阅者模式的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。 具体实现步骤: 当把一个普通 Javascript 对象传给 Vue 实例来作为它的 data 选项时，Vue 将遍历它的属性，用 Object.defineProperty 都加上 setter和getter 这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化 compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图 Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: 1、在自身实例化时往属性订阅器(dep)里面添加自己 2、自身必须有一个update()方法 3、待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。 MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546//vue实现数据双向绑定的原理就是用Object.defineproperty()重新定义（set方法）对象设置属性值和（get方法）获取属性值的操纵来实现的。//Object.property()方法的解释：Object.property(参数1，参数2，参数3) 返回值为该对象obj//其中参数1为该对象（obj），参数2为要定义或修改的对象的属性名，参数3为属性描述符，属性描述符是一个对象，主要有两种形式：数据描述符和存取描述符。这两种对象只能选择一种使用，不能混合使用。而get和set属于存取描述符对象的属性。//这个方法会直接在一个对象上定义一个新属性或者修改对象上的现有属性，并返回该对象。&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta charset=&quot;utf-8&quot;&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;myapp&quot;&gt; &lt;input v-model=&quot;message&quot; /&gt;&lt;br&gt; &lt;span v-bind=&quot;message&quot;&gt;&lt;/span&gt; &lt;/div&gt; &lt;script type=&quot;text/javascript&quot;&gt; var model = &#123; message: &quot;&quot; &#125;; var models = myapp.querySelectorAll(&quot;[v-model=message]&quot;); for (var i = 0; i &lt; models.length; i++) &#123; models[i].onkeyup = function() &#123; model[this.getAttribute(&quot;v-model&quot;)] = this.value; &#125; &#125; // 观察者模式 / 钩子函数 // defineProperty 来定义一个对象的某个属性 Object.defineProperty(model, &quot;message&quot;, &#123; set: function(newValue) &#123; var binds = myapp.querySelectorAll(&quot;[v-bind=message]&quot;); for (var i = 0; i &lt; binds.length; i++) &#123; binds[i].innerHTML = newValue; &#125;; var models = myapp.querySelectorAll(&quot;[v-model=message]&quot;); for (var i = 0; i &lt; models.length; i++) &#123; models[i].value = newValue; &#125;; this.value = newValue; &#125;, get: function() &#123; return this.value; &#125; &#125;)&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; Proxy 相比于 defineProperty 的优势Object.defineProperty() 的问题主要有三个： 不能监听数组的变化 必须遍历对象的每个属性 必须深层遍历嵌套的对象 Proxy 在 ES2015 规范中被正式加入，它有以下几个特点: 针对对象：针对整个对象，而不是对象的某个属性，所以也就不需要对 keys 进行遍历。这解决了上述 Object.defineProperty() 第二个问题 支持数组：Proxy 不需要对数组的方法进行重载，省去了众多 hack，减少代码量等于减少了维护成本，而且标准的就是最好的。除了上述两点之外，Proxy 还拥有以下优势： Proxy 的第二个参数可以有 13 种拦截方法，这比起 Object.defineProperty() 要更加丰富 Proxy 作为新标准受到浏览器厂商的重点关注和性能优化，相比之下 Object.defineProperty() 是一个已有的老方法。 vue-router 三种导航守卫 全局守卫 路由独享守卫 路由组件内的守卫 1.全局守卫vue-router全局有三个守卫： router.beforeEach 全局前置守卫 进入路由之前 router.beforeResolve 全局解析守卫(2.5.0+) 在beforeRouteEnter调用之后调用 router.afterEach 全局后置钩子 进入路由之后 使用方法: 1234567891011// main.js 入口文件import router from &apos;./router&apos;; // 引入路由router.beforeEach((to, from, next) =&gt; &#123; next();&#125;);router.beforeResolve((to, from, next) =&gt; &#123; next();&#125;);router.afterEach((to, from) =&gt; &#123; console.log(&apos;afterEach 全局后置钩子&apos;);&#125;); 2.路由独享守卫如果不想全局配置守卫的话，可以为某些路由单独配置守卫： 123456789101112const router = new VueRouter(&#123; routes: [ &#123; path: &apos;/foo&apos;, component: Foo, beforeEnter: (to, from, next) =&gt; &#123; // 参数用法什么的都一样,调用顺序在全局前置守卫后面，所以不会被全局守卫覆盖 // ... &#125; &#125; ]&#125;) 3.路由组件内的守卫 beforeRouteEnter 进入路由前, 在路由独享守卫后调用 不能 获取组件实例 this，组件实例还没被创建 beforeRouteUpdate (2.2) 路由复用同一个组件时, 在当前路由改变，但是该组件被复用时调用 可以访问组件实例 this beforeRouteLeave 离开当前路由时, 导航离开该组件的对应路由时调用，可以访问组件实例 this Vue的路由实现：hash模式 和 history模式hash模式：在浏览器中符号 “#”，#以及#后面的字符称之为hash，用window.location.hash读取； 特点：hash虽然在URL中，但不被包括在HTTP请求中；用来指导浏览器动作，对服务端安全无用，hash不会重加载页面。 hash模式下，仅hash符号之前的内容会被包含在请求中，如 http://www.xiaogangzai.com，因此对于后端来说，即使没有做到对路由的全覆盖，也不会返回 404 错误。 history模式：history采用HTML5的新特性；且提供了两个新方法：pushState()，replaceState()可以对浏览器历史记录栈进行修改，以及popState事件的监听到状态变更。 history模式下，前端的URL必须和实际向后端发起请求的URL一致，如 http://www.xxx.com/items/id。后端如果缺少对 /items/id 的路由处理，将返回 404 错误。 Vue-Router官网里如此描述：“不过这种模式要玩好，还需要后台配置支持……所以呢，你要在服务端增加一个覆盖所有情况的候选资源：如果 URL 匹配不到任何静态资源，则应该返回同一个 index.html 页面，这个页面就是你 app 依赖的页面。 组件之间的传值通信组件之间通讯分为三种: 父传子、子传父、兄弟组件之间的通讯 1. 父组件给子组件传值使用props，父组件可以使用props向子组件传递数据。 123456789101112131415161718//父组件vue模板father.vue:&lt;template&gt; &lt;child :msg=&quot;message&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./child.vue&apos;;export default &#123; components: &#123; child &#125;, data () &#123; return &#123; message: &apos;father message&apos;; &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415//子组件vue模板child.vue:&lt;template&gt; &lt;div&gt;&#123;&#123;msg&#125;&#125;&lt;/div&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, required: true &#125; &#125;&#125;&lt;/script&gt; 2. 子组件向父组件通信父组件向子组件传递事件方法，子组件通过$emit触发事件，回调给父组件。 123456789101112131415161718//父组件vue模板father.vue:&lt;template&gt; &lt;child @msgFunc=&quot;func&quot;&gt;&lt;/child&gt;&lt;/template&gt;&lt;script&gt;import child from &apos;./child.vue&apos;;export default &#123; components: &#123; child &#125;, methods: &#123; func (msg) &#123; console.log(msg); &#125; &#125;&#125;&lt;/script&gt; 123456789101112131415161718192021//子组件vue模板child.vue:&lt;template&gt; &lt;button @click=&quot;handleClick&quot;&gt;点我&lt;/button&gt;&lt;/template&gt;&lt;script&gt;export default &#123; props: &#123; msg: &#123; type: String, required: true &#125; &#125;, methods () &#123; handleClick () &#123; //........ this.$emit(&apos;msgFunc&apos;); &#125; &#125;&#125;&lt;/script&gt; 3. 非父子, 兄弟组件之间通信vue2中废弃了$dispatch和$broadcast广播和分发事件的方法。 父子组件中可以用props和$emit()。如何实现非父子组件间的通信，可以通过实例一个vue实例Bus作为媒介，要相互通信的兄弟组件之中，都引入Bus，然后通过分别调用Bus事件触发和监听来实现通信和参数传递。 Bus.js可以是这样: import Vue from &#39;vue&#39; export default new Vue() 在需要通信的组件都引入Bus.js: 1234567891011121314&lt;template&gt; &lt;button @click=&quot;toBus&quot;&gt;子组件传给兄弟组件&lt;/button&gt;&lt;/template&gt;&lt;script&gt;import Bus from &apos;../common/js/bus.js&apos;export default&#123; methods: &#123; toBus () &#123; Bus.$emit(&apos;on&apos;, &apos;来自兄弟组件&apos;) &#125; &#125;&#125;&lt;/script&gt; 另一个组件也import Bus.js 在钩子函数中监听on事件 12345678910111213import Bus from &apos;../common/js/bus.js&apos;export default &#123; data() &#123; return &#123; message: &apos;&apos; &#125; &#125;, mounted() &#123; Bus.$on(&apos;on&apos;, (msg) =&gt; &#123; this.message = msg &#125;) &#125; &#125; vuex的定义？使用？以及使用功能场景 vuex 就是一个仓库，仓库里放了很多对象。其中 state 就是数据源存放地，对应于一般 vue 对象里面的 data state 里面存放的数据是响应式的，vue 组件从 store 读取数据，若是 store 中的数据发生改变，依赖这相数据的组件也会发生更新 它通过 mapState 把全局的 state 和 getters 映射到当前组件的 computed 计算属性 vuex的使用 Vuex有5种属性: 分别是 state、getter、mutation、action、module; state Vuex 使用单一状态树,即每个应用将仅仅包含一个store 实例，但单一状态树和模块化并不冲突。存放的数据状态，不可以直接修改里面的数据。 mutations mutations定义的方法动态修改Vuex 的 store 中的状态或数据。getters 类似vue的计算属性，主要用来过滤一些数据。 action actions可以理解为通过将mutations里面处里数据的方法变成可异步的处理数据的方法，简单的说就是异步操作数据。view 层通过 store.dispath 来分发 action。 vuex 一般用于中大型 web 单页应用中对应用的状态进行管理，对于一些组件间关系较为简单的小型应用，使用 vuex 的必要性不是很大，因为完全可以用组件 prop 属性或者事件来完成父子组件之间的通信，vuex 更多地用于解决跨组件通信以及作为数据中心集中式存储数据。 使用Vuex解决非父子组件之间通信问题 vuex 是通过将 state 作为数据中心、各个组件共享 state 实现跨组件通信的，此时的数据完全独立于组件，因此将组件间共享的数据置于 State 中能有效解决多层级组件嵌套的跨组件通信问题。 vuex 作为数据存储中心 vuex 的 State 在单页应用的开发中本身具有一个“数据库”的作用，可以将组件中用到的数据存储在 State 中，并在 Action 中封装数据读写的逻辑。这时候存在一个问题，一般什么样的数据会放在 State 中呢？ 目前主要有两种数据会使用 vuex 进行管理： 1、组件之间全局共享的数据2、通过后端异步请求的数据 比如做加入购物车、登录状态等都可以使用Vuex来管理数据状态。 开发时，改变数组或者对象的数据，但是页面没有更新如何解决？ vue弹窗后如何禁止滚动条滚动？ 如何在 vue 项目里正确地引用 jquery 和 jquery-ui的插件]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[px与rem单位换算]]></title>
    <url>%2F2019%2F05%2F05%2Fpx%E4%B8%8Erem%E7%9A%84%E5%8D%95%E4%BD%8D%E6%8D%A2%E7%AE%97%2F</url>
    <content type="text"><![CDATA[方法一1em指的是一个字体的大小，它会继承父级元素的字体大小，因此并不是一个固定的值。任何浏览器的默认字体大小都是16px。因此，12px = 0.75em。实际应用中通常设置样式： html { font-size: 62.5%; } 1em = 10px。常用的1.2em理论上就是12px。 但是，这个换算在IE浏览器下不成立，1.2em会比12px稍大一些。 解决办法是把html标签样式中的62.5%改成63%，即： html { font-size: 63%; } 一般会在段首空两格。如果用px作为单位，对12px字体来说需要空出24px，对14px字体来说需要空出28px……这样换算非常不通用。如果用上em单位，1个字的大小就是1em，那两个字的大小就是2em。因此 p { text-indent: 2em; } 总结：px比em更加容易使用,em指字体高，任意浏览器的默认字体高都是16px。所以未经调整的浏览器都符合: 1em=16px，所以10px=0.625em。为了简化font-size的换算，需要在css中的body选择器中声明Font-size=62.5%，这就使em值变为16px*62.5%=10px, 这样12px=1.2em, 10px=1em, 也就是说只需要将原来的px数值除以10，然后换上em作为单位就行了。 em的特性 em的值并不是固定的； em会继承父级元素的字体大小。 浏览器默认的字号16px，px单位与rem之间的转换关系： 在元素中设置font-size值为62.5%:相当于在中设置font-size为10px，此时，所示的值改变： rem在众多浏览器中都已得到很好的支持，如果项目不用考虑IE8一下低版本的话，可放心的使用 方法二在页面写入核心原生JS代码： 1234567891011121314151617function (doc, win) &#123; var docEl = doc.documentElement, resizeEvt = &apos;onorientationchange&apos; in window ? &apos;onorientationchange&apos; : &apos;resize&apos;, recalc = function () &#123; var clientWidth = docEl.clientWidth; if (!clientWidth) return; if(clientWidth&gt;=750)&#123; docEl.style.fontSize = &apos;100px&apos;; &#125;else&#123; docEl.style.fontSize = 100 * (clientWidth / 750) + &apos;px&apos;; &#125; &#125;; if (!doc.addEventListener) return; win.addEventListener(resizeEvt, recalc, false); doc.addEventListener(&apos;DOMContentLoaded&apos;, recalc, false); &#125;)(document, window); 如果页面的宽度超过了750px，那么页面中html的font-size恒为100px，否则，页面中html的font-size的大小为： 100 * (当前页面宽度 / 750) 为什么是750px？对于手机屏幕来说，750px的页面宽度是一个安全的最大宽度，保证了移动端页面两边不会留白。这里的px是css逻辑像素，与设备的物理像素是有区别的。 如iPhone 5使用的是Retina视网膜屏幕，使用2px x 2px的 device pixel 代表 1px x 1px 的 css pixel，所以设备像素数为750 x 1136px，而它的CSS逻辑像素数为375 x 568px。如果要切移动端页面，可以先把效果图宽度等比例缩放到750px，很好用。 为什么要设置html的font-size？rem就是根元素（即：html）的字体大小。html中的所有标签样式凡是涉及到尺寸的（如： height,width,padding,margin,font-size。甚至，left,top等）可以放心大胆的用rem作单位。 如果把html的font-size设为20px，rem就是html的字体大小，那么1rem = 20px。 此时，此时宽60px，高40px的元素样式就这样设置如下 ↓ width: 3rem; height: 2rem; 要是宽55px，高37px,然后经过换算，，设置如下 ↓ width: 2.75rem; height: 1.85rem; 发现这换算起来有点麻烦啊，，，（当然，要是心算帝请无视）如果我们一开始把html的font-size设为100px呢？此时1rem = 100px，那么上面的宽，高就可以这么设置 width: 0.55rem; height: 0.37rem;换算起来简单多了？！ （为什么不一开始把html的font-size设为1px呢，这样换算起来也简单，答：浏览器一般都有最小字体限制，比如谷歌浏览器，最小中文字体就是12px，所以实际上没有办法让1rem=1px。） 根据上面的js代码，如果页面宽度低于750px,那么页面中html的font-size也会按照（当前页面宽度/750）的比例变化。这样，页面中凡是应用了rem的作尺寸单位的元素都会随着页面变化而等比例缩放了！ 哪些情况可以用rem布局:大部分情况下都可以用rem布局这个方法，具体还要看情况而定。比如底部的导航不用rem，而是用的flex布局。因为导航点击最多，所以给它一个固定的大小（其实就是高度固定，宽度自适应的方案） 心得在rem布局中小技巧：页面中模块间距离一般为0.2rem。字体的大小一般分为四个档次 0.2rem 0.24rem 0.28rem 0.32rem。 拿项目举例，我们移动端页面效果图的宽度都定在了750px。于是在项目中，最外层的div样式就设置成了 12345position: relative; width: 100%; max-width: 750px; min-width: 320px; margin: 0 auto; 所有的元素都可以写在这个div中了，于是就可以开始写样式了 rem布局中，如果有个元素需要水平居中固定到页面底部:(前提是这个元素还是在前面说的最外层水平居中的大div中) 123456position: fixed; bottom: 0; z-index: 100; width: 100%; max-width: 750px; min-width: 320px;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TCP三次握手和四次挥手]]></title>
    <url>%2F2019%2F04%2F15%2FTCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%2F</url>
    <content type="text"><![CDATA[TCP(Transmission control protocal):传输控制协议，机器与机器间传输信息的基础协议 HTTP(HyperText Transfer Protocol)：超文本传输协议，是web联网的的基础，也是手机联网的常用协议之一，HTTP协议是建立在TCP协议之上的一种应用 ps：（TCP/UDP） 服务端每对新的客户端的状态初始表现为Listen状态（即等待响应状态），就像美丽的姑娘正在等待着少年的搭讪 第一次握手： 客户端向服务端发送同步请求（尝试搭讪），报文信息（搭讪内容）为：SYN=1 ,seq=q；同步请求TRUE，序号为w，客户端状态更改为：syn-sent ,表示同步请求已发送,这时客户端只要耐心的等待服务端姑娘的回应 (SYN是synchronization同步的简称，seq为sequcence序号的缩写。) 第二次握手： 服务端接收到心里有好感的客户端发来的同步请求，心中一定，服务端状态从Listen更改为syn-received，表示已接收同步请求，并且阅读了搭讪内容，但美丽的姑娘心思总是细腻的，她小心而珍重的发出确认信息：SYN=1,ACK=1,ack=q+1,seq=e，ACK为ACK是acknowledgement确认的简称，小写ack为确认信息的编号，seq为服务端发送报文的序号，这时服务端等待客户端的回应，内心os:他是真的对我有意思吗？ 第三次握手： 客户端收到美丽姑娘发来的确认验证连接报文，内心欣喜不已，他美滋滋的回应：是的是的，没错,我的序号是q+1(肯定美丽姑娘的内容后+扩展话题( •́ .̫ •̀ ))：syn=1，ACK=1，ack=e+1,seq=q+1 (在客户端收到服务端发送的TCP建立验证请求后，客户端向服务器给出确认。返回服务器ACK=1，确认编号ack=e+1，在自己的序号上加上seq=q+1。 发送完报文后客户端状态更改为establish，服务端收到已确认报文信息，状态更改为establish，然后双方就可以愉快正经的交流惹（数据传输）！美丽邂逅下的交流开始展开…… 这就是TCP的三次握手 年龄总是如期而来，忧愁总是不请自来，不幸总是突如其来，离别总要到来. 只有一个体面的离别，才意味着未来依然可以关系持续升温。 作为主动方的客户端，需要首先表示分别，千万不要拖泥带水等到服务端提出，这样才能为这段邂逅留下回味与不舍 第一次挥手： 这时，客户端需要提出分别，并给出具体信息，客户端进程发出连接释放报文（加戏：并且提出要求要女孩的手机号），并且停止发送数据。设置报文信息为：FIN=1，其序列号为seq=u ；FIN为finish的缩写，客户端已经请求结束了，安静地等待。 主动而沉默，给予服务端足够的空间，这是最体面的分别方式。发送完后，这时客户端的状态从establish更改为FIN-WAIT-1（终止待待1） 第二次挥手： 服务器收到连接释放报文，热烈的聊天突然戛然而止，发出确认报文，ACK=1，ack=u+1，seq=v。美丽的姑娘总是会有点失落的，虽然不舍，但因为是对方提出离开，一方面会同意离开，一方面会延展对方话题。她一般会说一个新话题，比如下雨了。 服务端发出确认连接释放报文的时候，服务端状态更从establish改为CLOSE_WAIT状态，她会开始进行心理建设，适应少年要离开的这个事实。 当然，成年人的表达方式，总是隐晦而体面的。只是一句淡淡的“天快下雨了”。 而客户端听到她说这些（收到确认报文信息后），只是静静不说话。客户端进入FIN-WAIT-2状态。客户端在等着服务端的手机号，话说可能她突然不给了呢？忍住，别回应。 第三次挥手： 服务端看你不回应，她会换个话题，开始猜，开始等，并且有了想法，在等待客户端回应的时间里，服务端已经做好了分别的心理建设，知道这一次邂逅到此为止了，这时，服务端同意分开，并再次根据客户端原先发来的具体信息主动发送连接释放报文：FIN=1，ACK=1, ack=u+1，seq=w，发送完这句话的服务端，进入了LAST_ACK(最终动作)状态——主动权在你，她等着你。 客户端听到服务端再次说话，客户端内心也有点不舍，他等着些什么。客户端进入TIME_WAIT阶段。 第四次挥手： 客户端知道离开已成必然，他的心会骤然一痛，但还是要说完最后体面的话：客户端收到服务端的确认连接释放后，必须给出回应，发送报文：ACK=1，ack=w+1，而自己的序列号是seq=u+1。 收到客户端发完的报文，服务端进入closed状态（关闭连接），头也不回的离去 而主动提出分别的客户端，却久久站在原地，等了2MSL(两次交谈响应时间那么长)，希望那个美丽的姑娘能够回头看他一眼 但一切没有发生。美好的邂逅结束了。客户端进入CLOSED状态 总结：三次握手: SYN=1, seq=x客户端发进入SYN_SENT状态。 SYN=1,ACK=1,ack=x+1,seq=y服务端进入SYN_Received状态 ACK=1,ack=y=1,seq=x+1发送后客户端进入establish状态服务端接收后进入eatablelish状态 四次挥手： FIN=1，seq=u客户端从restablish状态进入fin-wait-1状态 ACK=1, ack=u+1, seq=v发送后，服务器从ESTABLISHED状态，进入CLOSE-WAIT状态。收到后，客户端从FIN-WAIT-1状态，进入FIN-WAIT-2状态。 FIN=1, ACK=1, ack=u+1, seq=w发送后，服务器从CLOSE-WAIT状态，进入LAST_ACK状态 ACK=1, ack=w+1, seq=u+1发送后，客户端从FIN-WAIT-2进入TimeWait状态接收后，服务端从Close-wait状态进入CLosed状态 客户端等待2MSL(两次交谈响应时间那么长)，状态变更为closed状态 ps:每一次通讯，都会改变状态每一次通讯，都带有seq码SYN在握手阶段双方各发一次FIN在挥手阶段双方各发一次有 确认码的时候ACK=1，必须带有ack编号,ack在上一条接到的序号上+1 ps:]]></content>
      <categories>
        <category>TCP</category>
      </categories>
      <tags>
        <tag>tcp</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Vue+Vue-cli+Vue-router+webpack构建web移动端app]]></title>
    <url>%2F2019%2F03%2F15%2FVue%2F</url>
    <content type="text"><![CDATA[一、npm安装vuenpm install vue@版本号 二、npm安装全局脚手架npm install -g vue-cli vue脚手架是帮助写好Vue基础代码的工具，其中包括： 目录结构 本地调试 代码部署 热加载 单元测试 三、创建基于webpack模板构的vue项目vue init webpack 项目名字 四、进入创建的项目目录试运行cd 项目目录下 npm run dev 五、you application is run here:http://localhost:8080四、项目目录结构解读： src文件夹：存放项目源码 bulld目录+ config目录webpack配置相关 node_modules文件夹：npm install 安装的依赖代码库 static—&gt;.gitkeep: 当这个目录为空时也可以将它提交到git仓库中 babelrc : babel的一些配置，es6语法的转换 .editorconfig: 编辑器的配置 .eslintignore: 忽略语法检查的目录文件，一般忽略build目录和node_modules目录 .eslintrc.js: eslint的配置文件 gitignore: 上传git仓库要忽略的一些文件的配置 index.html: 入口html文件，要使用的css和js文件会在编译过程中自动插入 package.json：整个项目的配置文件，一般用来描述项目 scripts: 配置一些需要执行的命令 dependencies：开发环境中的依赖 devdependencies： 编译过程中的依赖 src开发目录下： main.js —— 项目入口文件 App.vue —— 主页面组件 vue语法糖: export default { }一个对象——可以定义一个组件 【小知识点】sublime自动格式化 —— Command+option+L 或 Control+alt+L 在vue项目中，项目的入口文件为main.js，而app.vue作为所有组件的主组件,router文件夹下的index.js作为路由配置，为SPA应用配置路由 在父组件中使用子组件引用-注册-使用标签），如Hello.vue:引用 import Hello from ‘./compoments/Hello’ 注册12345export default&#123; components: &#123; Hello //es6语法 相当于 &apos;Hello&apos;: Hello &#125; &#125; 使用标签` ` 开发时的Webpack配置与编译build-&gt;dev-server.js 或 Webpack.dev.conf.jswebpack.base.conf.js : 配置各种文件的Loader 配置默认识别的路径1234567resolve: &#123; extensions: [&apos;.js&apos;, &apos;.vue&apos;, &apos;.json&apos;], alias: &#123; &apos;vue$&apos;: &apos;vue/dist/vue.esm.js&apos;, &apos;@&apos;: resolve(&apos;src&apos;), &#125;&#125; 五、准备工作图标字体制作 ： 在线制作网站：https://icomoon.io/app/#/select 将自己的SVG图标导入，输出自己的图标字体文件 Import Icons → Generate Fonts → preferences修改名称 → Download 使用：icon.css和fonts文件夹下所有文件 项目目录设计src-&gt;common目录下：项目公用文件 js、style、fonts 项目css构建工具用到stylusnpm install stylus stylus-loader --save-dev 【css的stylus语法】无需任何符号,tab键退格下表示下级元素， &amp;表示父元素，冒号也可以省略，文件后缀为styl，style中添加lang=”stylus” 样式重置引入样式重置表 六、前后端分离Vue SPA —— 前端通过 vue-resource Ajax从后端获取数据 前端最重要的任务：mock数据（后台数据模拟） 引入data.jsondata.json 12345&#123; &quot;seller&quot;:&#123;&#125; //商家相关字段 &quot;goods&quot;:&#123;&#125; //商品相关字段 &quot;rattings&quot;:&#123;&#125; //评论相关字段&#125; 使用 express框架 开启一个node server,用 express.Router 编写这些接口请求 webpack.dev.conf.js中配置 首先：在 const portfinder = require(‘portfinder’) 后添加 123456789const express = require(&apos;express&apos;)//开启一个node serverconst app = express() //定义一个对象，包含express返回的数据var appData = require(&apos;../data.json&apos;) //定义一个对象引入data数据var seller = appData.seller;var goods = appData.goods;var ratings = appData.ratings;app.use(&apos;/api&apos;, apiRoutes); //调用app对象 找到 devserver{}, 在里面添加 1234567891011121314151617181920before(app) &#123; app.get(&apos;/api/seller&apos;, (req, res) =&gt; &#123; res.json(&#123; errno: 0, //错误码：实际上是业务方根据业务自己定的 data: seller &#125;) //接口返回json数据，上面配置的数据seller就赋值给data请求后调用 &#125;), app.get(&apos;/api/goods&apos;, (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: goods &#125;) &#125;), app.get(&apos;/api/ratings&apos;, (req, res) =&gt; &#123; res.json(&#123; errno: 0, data: ratings &#125;) &#125;)&#125; 配置完重启 查看json数据在Google地址栏中输入：localhost:8080/api/seller 谷歌安装插件jsonview是数据格式化方便查看]]></content>
      <categories>
        <category>vue</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fcc闯关重温知识点整理]]></title>
    <url>%2F2019%2F02%2F28%2FFCC%E9%97%AF%E5%85%B3%E9%87%8D%E6%B8%A9%E7%9F%A5%E8%AF%86%E7%82%B9%EF%BC%88Jquery%E7%AF%87%EF%BC%89%2F</url>
    <content type="text"><![CDATA[引入jQuery库和Animate.css动画库：引用JQuery库： 1.直接引用官网的cdn &lt;script src=&quot;http://code.jquery.com/jquery-1.10.1.min.js&quot;&gt;&lt;/script&gt; 2.下载jQuery-1.10.1.min.js，引入所在的路径 引用animate动画库： 1.从官网下载： https://raw.github.com/daneden/animate.css/master/animate.css 2.通过npm下载：$ npm install animate.css 3.使用在线cdn：https://unpkg.com/animate.css@3.5.2/animate.min.css $(document).ready(function(){}); // 需要在浏览器渲染完HTML之后加载js代码，否则会有bug；或者在body的里面，所有的Html节点最后面写script。这样你就可以在编辑器里直接可以使用这两个库，进而通过jQuery给button元素添加bounce回弹动画效果。 JQuery操作HTMLQuery的.html()方法可以添加HTML标签和文字到元素，而元素之前的内容都会被方法的内容所替换掉。jQuery有一个.prop()的方法让你来调整元素的属性比如，你可以让按钮变不可选。当你把按钮设置成不可选以后，这会让按钮变灰并且不能点击。$(“#demo”).prop(“disabled”,true); //修改属性禁用按钮 jQuery 还有一个类似的方法叫.text()，它只能改变文本但不能修改标记。换句话说，这个方法只会把传进来的任何东西(包括标记)当成文本来显示。 .html() 方法修改HTMl时页面实时显示效果 ，eg:$(“#demo”).html(“要强调的内容，原文copy过来“); .text（”要修改的文字”）只是单纯修改文字，不会识别html的元素 Query 有一个.remove() 的方法可以移除HTML元素 尝试把元素从一个div里移到另外一个div里。 jQuery有一个appendTo()方法可以把选中的元素加到其他元素中。 除了移动元素，你还可以拷贝元素。简单理解：移动元素就是剪切，拷贝元素就是复制。$(“#demo”).clone().appendTo(“#xixi”); 方法连写，复制一个div并追加到另一个DIv jQuery有一个方法叫parent()，它允许你访问指定元素的父元素。 jQuery有一个方法叫children()，它允许你访问指定元素的子元素。 JQuery 操作css我们可以通过jQuery来改变HTML元素的CSS样式。 jQuery有一个叫做.css()的方法能让你改变元素的CSS样式1$(&quot;#target1&quot;).css(&quot;color&quot;, &quot;blue&quot;); 这跟通常的CSS语法有点不同，这里CSS的属性和值是在引号内的，并且用逗号分开。 添加class用 $(“button”)来选中按钮，然后用.addClass(“animated bounce”)给按钮加CSS class。 用jQuery的.addClass()方法，就可以给元素加class了。123$(&quot;button&quot;).addClass(animated bounce);$(&quot;button&quot;).addClass(animated bounce);shake动摇，bounce弹跳$(&quot;#demo&quot;).addClass(&quot;animated fadeOut&quot;); // fadeOut逐渐消失 通过jQuery的addClass()方法给元素添加class,也可以通过jQueryremoveClass()方法去掉元素上的class。1.addClass(&quot;&quot;);——.removeClass(&quot;&quot;); 超好玩的：给bodty添加动画:1$(&quot;body&quot;).addClass(&quot;animated hinge&quot;); //悬挂退出 获取索引JQ获取节点的索引值为基数的索引元素，并添加引入的动画属性1shake:$(&quot;.demo:odd&quot;).addClass(&quot;aninated shake&quot;); JQ获取节点的索引值为基数的索引元素，并添加引入的动画属性1bounce:$(&quot;.demo:even&quot;).addClass(&quot;aninated bounce&quot;); 使用：even功能来更改这些元素 ：even筛选出元素的索引值为偶数的的元素：odd功能选择索引值为基数的元素 even：偶数的；odd：基数的]]></content>
      <categories>
        <category>Jquery</category>
      </categories>
      <tags>
        <tag>Jquery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fcc闯关重温知识点整理]]></title>
    <url>%2F2019%2F01%2F29%2Ffcc%E9%97%AF%E5%85%B3%E9%87%8D%E6%B8%A9%E7%9F%A5%E8%AF%86%E7%82%B9(bootstrap%E7%AF%87)%2F</url>
    <content type="text"><![CDATA[—————— Read! Search! Ask! bootstrap框架： 仅需通过添加下列代码到HTML头部文件哪里即可引用bootstrap框架到你的任意应用中：1&lt;link rel=&quot;stylesheet&quot; href=&quot;//cdn.bootcss.com/bootstrap/3.3.1/css/bootstrap.min.css&quot;/&gt; 引入bootstrap后，直接引用里面写好的类来调样式 图片自适应：&lt;img class=&quot;img-redponsive&quot;&gt; 文本居中 ：&lt;p class=&quot;center&quot;&gt; button属性：&lt;button class=&quot;btn btn-block &quot;&gt;//btn为bootstrap的独有的按钮风格，btn 默认 为行内的元素，所以加上btn-block类属性让其独占一行 常用颜色 ： &lt;button class=&quot;btn btn-block btn-primary&quot;&gt;//priamry为深蓝色，颜色可应用于各种元素，如：text-priamry &lt;button class=&quot;btn btn-block btn-info&quot;&gt; //info为浅蓝色 &lt;button class=&quot;btn btn-block btn-danger&quot;&gt; //danger为红色 well类 ：Bootstrap 有一个 class 属性叫做 well，它的作用是为设定的列创造出一种视觉上的深度感（一种视觉上的效果，动手写代码体会一下）：12&lt;div class=&quot; #left-well well&quot;&gt;&lt;/div&gt; &lt;div class=&quot;#right-well well&quot;&gt;&lt;/div&gt;效果 bootstrap网格式布局: Bootstrap 使用一种响应式网格布局——可轻松实现将多个元素放入一行并指定各个元素的相对宽度的需求class属性 col-md- 来调节布局。在这里，col 是列；md 表示 medium (中等的)，可取值为、lg、md、xs； 代表一个数字，它指定了这个元素所占的列宽，即占多少个单元格。 常用用法：.row与.col-xs- 搭配使用，其中.row类应作为ol-xs-类的父元素的类存在； xs 是 extra small 缩写（应用于较小的屏幕，比如手机屏幕），*是你需要填写的数字，代表在一行中,各个元素应该占的列宽（即所占多少单元格）.row为12格栅，col为12格栅的比例。 eg: 12345&lt;form class=&quot;row&quot; method=&quot;get&quot; action=&quot;url&quot;&gt; &lt;button class=&quot; btn btn-primary col-xs-5&quot;&gt; thumb &lt;/button&gt; &lt;button class=&quot;btn btn-info col-xs-5&quot;&gt; love &lt;/button&gt; &lt;button class=&quot;btn btn-danger col-xs-5&quot;&gt; hate &lt;/button&gt;&lt;/form&gt; bootstrap的超赞图标库Font Awesome Font Awesome 是一个bootstrap非常方便的图标库。这些图标都是矢量图形，被保存在 .svg 的文件格式中。这些图标就和字体一样，你可以通过像素单位指定它们的大小，它们将会继承其父HTML元素的字体大小。你可以将 Font Awesome 图标库增添至任何一个应用中，方法很简单，只需要在你的 HTML 头部增加下列代码即可：1&lt;link rel=&quot;stylesheet&quot; href=&quot;https://cdn.bootcss.com/font-awesome/4.2.0/css/font-awesome.min.css&quot;/&gt; 引入Font Awesome后直接调用写好的类来添加图标 &lt;i class=&quot;fa fa-thumbs-up&quot; &gt;&lt;/i&gt; //在bootstrap中i标签用来表示图标 ，调用Font Awesone里面写好的类.fa .fa-图标代表; 常用的图标有：fa-thumbs-up(点赞图标)、fa-info-circle（信息图标）、fa-thumbs-trash（删除图标）fa-paper-plan(纸飞机图标，常用于提交按钮)]]></content>
      <categories>
        <category>bootstrap</category>
      </categories>
      <tags>
        <tag>bootstrap</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[window下flutter安装踩坑篇]]></title>
    <url>%2F2018%2F12%2F28%2Ffirst%2F</url>
    <content type="text"><![CDATA[说实话，flutter安装起来真的不容易，哭唧唧，下面是我的安装踩坑篇准备工作：科学上网 window系统高于系统高于win7以上64位操作系统 flutter SDK SDK的磁盘空间大于3个G，虽然官方说400M,但是后面还要安装Andriod Studio和虚拟机 需要git环境支持，所以电脑上需要预装git 由于在国内开发的原因：预先在放flutter SDK的文件夹下配置好国内可靠本地镜像站点，指示flutter工具使用备用存储位置（翻墙了这步可以省略） 12export PUB_HOSTED_URL=RL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=RL=https://storage.flutter-io.cn 如果想在任何地地方都可以使用flutter命令，把flutter 的bin目录配置到用户环境变量的path条目下。 第一步：安装flutter SDK看过很多教程都是用git工具先直接在GitHub上clone下来，我也试试git clone -b beta ta https://github.com/flutter/flutter.git 第二步：配置环境变量，让我们可以直接在系统命令终端上执行flutter命令在新建的文件夹下右键git bash执行clon之后，远程仓库上的flutter SDK已得到，配好系统的环境变量：path fultter的bin目录路径（小娜输入：evn快速进入系统环境变量配置界面)配好变量之后，事实证明克隆下来的flutter安装不行报错显示：“Unknown operating system. Cannot install Dart SDK”，git下来的才60多MB，真坑于是到官网自行下载window版本的安装包 [官网：https://flutter.io/docs/get-started/install/windows] 第三步：配置flutter SDK ：执行flutter doctor 检查并更新dart sdk，下载依赖自动安装配置打开命令终端（管理员）（或者在flutter的bin目录下打开 git bash执行也是可以的）先看下flutter –version出现版本号然后然后跑：flutter doctor按照博客教程走，无任何意外情况下会下载一次载一次dart.zip并顺利解并顺利解压。但是，运行flutter doctor 的时候第一次报错，“erro:Unable to Find git in your path”，奇怪，我记得以前配过git的path鸭，于是搜索解决方案:在系统环境变量中再次添加git的bin目录下路径 再次跑flutter doctor ;又一次报错 “powershell命令提示符出现“不是内部或外部命令，也不是可运行的程序或批处理文件”在环境变量 path 中又添加本系统的PowerShell 的路径：C:\Windows\System32\WindowsPowerShell\v1.0关闭命令终端吼重新打开再次运行 flutter doctor然后再次报错1Doctor summary (to see all details, run flutter doctor -v):Oops; flutter has exited ed unexpectedly.Sending cra crash report to Google 哦~ ，flutter 出乎意料的退出了，发送崩溃报告给谷歌~~~~ 搜到解决方案，需要设置两个环境变量来升级Flutter并使用中国的pub包存储库 PUB_HOSTED_URL和 FLUTTER_STORAGE_BASE_URL是谷歌为国内开发者搭建的临时镜像，详情参考：Using Flutter in China 在用户变量中再次配置名为PUB_HOSTED_URL”和”FLUTTER_STORAGE_BASE_URL的条目或者在flutter的bin目录下git bash输入 export PUB_HOSTED_URL=https://pub.flutter-io.cn export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn 完了之后再次输入：flutter doctor，报错提示：未知的操作系统。无法安装DART SDK $ flutter doctor Downloading Dart SDK from Flutter engine 66072316382837e66aaea518d219192a80839fc Unknown operating system. Cannot install Dart SDK. 翻博客,得到解决方案：到Flutter的bin目录,运行 flutter.bat doctor而不是flutter doctor ，顺带博主提供的解决问题的GitHub flutter的issue：https://github.com/flutter/flutter/issues/8860 从头再来分割线：第一步：到官网下载flutter SDK安装包第二步：在安装包下找到flutter_console.batd运行，输入flutter 命令：flutter doctor安装依赖等第三步：安装android studio（科学上网) 到官网自行下载适用自己系统版本的android studio。下载用了蛮久 官网:https://developer.android.com/studio/#downloads 上面网址提供的32位安装包没有install.exe文件，后来我下的是一个win32和64位都适用的一个版本，地址： http://www.android-studio.org/index.php/download/hisversion/169-androidstuio-pan-v1-2 安装（因为在安装Android Studio的时候，要到google的网站下很多的包，但是谷歌被墙的厉害，所以比较耗时间 配置Android studio安装Android证书 第四步：安装AVD虚拟机 Flutter跑起来 在基础的环境安装完成后，打开Android Studio可以新建一个Flutter项目了。如果你有手机（真机）来进行预览效果是最好的，但是为了我们前端追求的热更新，我们还是需要建立一个虚拟机的。 打开Andorid Studio ，新建Flutter项目。如果你幸运的话，你的Flutter程序经过编译后，就会跑起来了。（这种幸运的机会很小）]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
</search>
